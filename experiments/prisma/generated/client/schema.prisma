datasource postgres {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

type Numeric = Float

generator client {
  provider        = "prisma-client-js"
  // binaryTargets   = ["windows", "debian-openssl-1.1.x"]
  binaryTargets   = ["native", "windows", "debian-openssl-1.1.x"]
  output          = "../prisma/generated/client"
  previewFeatures = ["orderByRelation", "nApi", "selectRelationCount", "orderByAggregateGroup", "referentialActions"]
}

generator typegraphql {
  provider                 = "node ../src/cli/dev.ts"
  output                   = "../prisma/generated/type-graphql"
  emitDMMF                 = true
  simpleResolvers          = false
  useUncheckedScalarInputs = false
}

enum TrafficSourceName {
  CONTENT_AD
  OUTBRAIN
  TABOOLA
}

model TrafficSource {
  id        String            @id @default(cuid())
  name      TrafficSourceName @unique
  clickData ClickData[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

model ClickData {
  id              String        @id @default(cuid())
  trafficSource   TrafficSource @relation(fields: [trafficSourceId], references: [id])
  trafficSourceId String
  // Metrics
  date            DateTime
  campaignId      Int
  campaignName    String
  adId            Int?
  device          String
  country         String?
  domainId        Int
  clicks          Int
  spend           Float
  excludedClicks  Int
  conversions     Int
  ecpc            Float
  ecpa            Float

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // @@index([campaignId, adId, domainId])
  // TODO: Do we really want separate indexes?
  @@index([campaignId])
  @@index([adId])
  @@index([domainId])
}

enum AccountType {
  /// Bing Ads account type
  BING_ADS
  /// Google Ads account type
  GOOGLE_ADS
  CLICKBANK
  MAXWEB
}

model FunnelAccount {
  id      String      @id @default(cuid())
  /// Type of the account to enable acount linking if type differs.
  type    AccountType
  /// Name or identifier of the account. If account is an affiliate account, this should be set to the affiliate id.
  name    String      @unique
  domains Domain[] /// Domains linked to the account. Only applies to certain account types.

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  Funnel   Funnel? @relation(fields: [funnelId], references: [id])
  funnelId String?

  @@index([name])
}

model Domain {
  id           String    @id @default(cuid())
  name         String    @unique
  state        String // Change to enum (new,stale,burned,etc.)
  creationDate DateTime? /// When domain was first rent. // TODO: Change to required

  // Internal
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  FunnelAccount   FunnelAccount? @relation(fields: [funnelAccountId], references: [id])
  funnelAccountId String?
}

model Funnel {
  id               String    @id @default(cuid())
  name             String
  order            Int?      @unique /// Order for list sorting
  trafficFirstSeen DateTime? /// Used for later on analytics and data crunching

  // TODO: Maybe change this to Profiles in general to be compatible with other providers (e.g. crown)
  cards          Int[]  @unique
  browserProfile String @unique

  linkedAccounts FunnelAccount[] /// Accounts linked to the funnel, to track all belonging settings etc.

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Test if this works, so each combination is purely unique
  @@index([name, cards, browserProfile])
}
